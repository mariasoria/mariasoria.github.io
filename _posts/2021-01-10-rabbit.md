---
title: "Eventos as√≠ncronos, Rabbitmq y protocolo AMQP"

# multilingual page pair id, this must pair with translations of this page. (This name must be unique)
lng_pair: id_autogeneratedsamplecontent_6

# post specific
# if not specified, .name will be used from _data/owner/[language].yml
author: Maria Soria
# multiple category is not supported
category: auto generated
# multiple tag entries are possible
tags: [events, rabbitmq]
# thumbnail image for post
img: ":rabbitmq.png"
# disable comments on this page
comments_disable: true

# publish date
date: 2021-01-10 17:25:34 +06:00

# seo
# if not specified, date will be used.
#meta_modify_date: 2021-08-10 11:32:53 +0900
# check the meta_common_description in _data/owner/[language].yml
#meta_description: ""

# optional
# if you enabled image_viewer_posts you don't need to enable this. This is only if image_viewer_posts = false
#image_viewer_on: true
# if you enabled image_lazy_loader_posts you don't need to enable this. This is only if image_lazy_loader_posts = false
#image_lazy_loader_on: true
# exclude from on site search
#on_site_search_exclude: true
# exclude from search engines
#search_engine_exclude: true
# to disable this page, simply set published: false or delete this file

---

La verdad es que nunca hab√≠a trabajado con eventos as√≠ncronos antes. Siempre me hab√≠a limitado a mandar peticiones s√≠ncronas y recibir una respuesta "inmediata".

Me un√≠ a un proyecto en el que se usaba este tipo de comunicaci√≥n. Cuando llegu√©, mis compa√±eros hablaban de eventos, exchanges, colas, publishers, consumers...y obviamente, la cabeza me explot√≥ ü§Ø.
Por si fuera poco, poco tiempo despu√©s descubr√≠ que dicho proyecto, no s√≥lo mandaba eventos al exterior para que otros los consumieran, sino que tambi√©n mandaba eventos internos que nosotros mismos consumiamos en el propio proyecto... WHAT?

Pues bien, nuestro proyecto es un monolito con renderizaci√≥n en backend que se comunica con un segundo backend a trav√©s de eventos. Esta gesti√≥n de eventos se realiza con [Rabbitmq](https://www.rabbitmq.com/), el cual los recibe y enruta.

### Rabbitmq

Rabbitmq es un gestor de mensajes (message broker). Recibe mensajes de un *publisher* y los enruta al/a los *consumer/s*. Es open source y compatible con muchos OS y entornos. Admite m√∫ltiples [protocolos](https://www.rabbitmq.com/protocols.html) de mensajer√≠a, aunque nosotros en este proyecto en concreto utilizamos el protocolo [AMQP](https://www.amqp.org/about/what) , la versi√≥n 0.9.1.

### Protocolo [AMQP](https://www.amqp.org/about/what) (Advanced Message Queueing Protocol)

Las caracter√≠sticas principales de este protocolo son los exchanges, las colas y los enrutamientos.

Este protocolo se basa en que un exchange decide* a qu√© cola debe enrutar el mensaje que ha recibido. Luego esa cola se enlazar√° con un *channel* que consumir√° el *consumer*.

*Seg√∫n las condiciones que nosotros elijamos, por ejemplo: el tipo de clave que contiene el mensaje.

Proceso (muy simplificado):

- El *publisher* env√≠a un mensaje a un *exchange*.
- El *exchange* selecciona la cola a la que lo debe enviar.
- Lo env√≠a por la cola que luego "bindea" con un *channel*.
- El *consumer* "recoge" el mensaje de ese *channel*.

![Rabbitmq|690x184](upload://rs2gcAqFGgOEb4HBobAb8Xm21dU.png)

Toda la configuraci√≥n de exchanges, colas, etc, est√° hecha (sorprendentemente, al menos para m√≠) en ficheros xml.

### Pero a ver, ¬øc√≥mo se pone en pr√°ctica eso?

Digamos que queremos enviar un mensaje desde el *publisher* en el que queremos indicar al *consumer* que debe sincronizar (event) datos de un usuario (entity).

Estructura mensaje para este ejemplo:

- En **headers**, especificamos el tipo de evento y la entidad a la que queremos aplicarle una acci√≥n.
- Y en **payload**, indicamos la *data* que queremos que llegue al consumer.

Lo publicamos a trav√©s de un gateway:

```java
def headers = [
                'eventType'  : 'sync',
                'entityType' : 'user',
	            ]
def payload = [ userId: user.id ]

ourGateway.send(headers, payload.toString())
```

(Y ahora empieza la fiesta de los xml ü•≥  )

En este [enlace](https://docs.spring.io/spring-integration/reference/html/amqp.html#amqp) pod√©is encontrar m√°s informaci√≥n acerca de la sintaxis a seguir en los xml.

Pasos a seguir para establecer la comunicaci√≥n entre nuestro *publisher* y nuestro *consumer*:

1. Definimos ourGateway y le asignamos un *channel* que filtrar√° todos los mensajes que lleguen por ese gateway y los enviar√° a los *channels* que le indiquemos. Puesto que nosotros le hemos puesto en *header* un "*eventType*" enviar√° estos mensajes al *channel* "ourChannelPublisher". (Es necesario definir cada *channel*/cola.)

   *publisher-common.xml*


    ```xml
    <int:gateway id="ourGateway"
                     service-interface="ourproject.Publisher"
                     default-request-channel="gatewayChannel">
    </int:gateway>

    <!-- Definici√≥n channel -->
    <int:channel id="gatewayChannel"/>

    <int:filter input-channel="gatewayChannel"
                    expression="headers.containsKey('eventType')"
                    output-channel="ourChannelPublisher"
                    discard-channel="otherChannel"/>

    <!-- Definici√≥n channels -->
    <int:channel id="ourChannelPublisher"/>
    <int:channel id="otherChannel"/>
    ```

2. Enlazamos ese *channel* "ourChannelPublisher" con un *exchange* de salida que "*bindearemos" a* una cola. (Tendremos que definir tanto el exchange como la cola en un fichero de configuraci√≥n. Punto 3).

   *publisher-amqp.xml*

    ```xml
    <!-- Enlazamos el channel con un exchange de salida -->
    <int-amqp:outbound-channel-adapter channel="ourChannelPublisher"
    									   exchange-name="${integration.rabbitmq.internalSyncExchangeName}"
    									   mapped-request-headers="*"
    									   amqp-template="template" />

    <!-- Definimos una cola a la que "*bindearemos"* ese *exchange* -->
    <rabbit:queue id="internalSyncQueue" name="${integration.rabbitmq.internalSyncQueueName}" />

    <!-- Lo bindeamos con fanout, que significa que los mensajes ir√°n a todas las colas bindeadas-->
    <rabbit:fanout-exchange id="internalSyncExchange" name="${integration.rabbitmq.internalSyncExchangeName}" >
    		<rabbit:bindings>
    			<rabbit:binding queue="internalSyncQueue" />
    		</rabbit:bindings>
    </rabbit:fanout-exchange>
    ```

3. Definimos la configuraci√≥n tanto del *exchange* de salida como de la cola que hemos usado en el fichero publisher-amqp.xml.

   *integrationCoreDefaultConfig.groovy*

    ```json
    integration {
    	activateAMQP = false
    	rabbitmq {
    		// Queues
    		internalSyncQueueName = "myApp.sync.queue"
    		// Exchanges
    		internalSyncExchangeName = "myApp.sync.exchange"
    	}
    }
    ```

4. El mensaje est√° enviado, y se podr√≠a ver desde la interfaz gr√°fica de Rabbitmq en el exchange  "myApp.sync.exchange".
   Pero queremos tambi√©n consumirlo, as√≠ que, antes de definir el *consumer*, necesitamos 2 ficheros xml m√°s que configuran la conexi√≥n entre los *publishers* y los *consumers*.

   *publisher-memory.xml*

   ```xml
    <int:bridge input-channel="ourChannelPublisher" output-channel="queueOurChannelPublisher"/>
    <!-- Definimos el channel queueOurChannelPublisher  -->
    <int:channel id="queueOurChannelPublisher">
    	<int:queue/>
    </int:channel>
   ```

   Relacionamos "ourChannelPublisher" con "ourChannelConsumer":

   (Usamos un service-activator. *Activator* indica que ser√° un *consumer* que "consumir√°" el mensaje. En este caso, llamaremos a una clase con un m√©todo para que reconstruya el mensaje (clase: *dummyEchoServiceActivator.groovy,* m√©todo*: activate)*.

   *consumer-memory.xml*

   ```xml
    <int:service-activator input-channel="queueOurChannelPublisher" output-channel="ourChannelConsumer"
    						   ref="dummyEchoServiceActivator" method="activate">
    	<int:poller fixed-delay="2000"/>
   </int:service-activator>

   <!-- bean de la clase que recontruye el mensaje -->
   <bean id="dummyEchoServiceActivator" class="path.consume.DummyEchoServiceActivator"/>
   ```


5. Para poder consumir el mensaje, una vez creada la conexi√≥n entre el *publisher* y el *consumer*, es necesario conectar la cola por la que se enviaban los mensajes desde el publisher al *channel* al que estar√° suscrito nuestro consumer.

   Para el consumer ser√° mediante el "**inbound**-channel-adapter" (para el publisher antes hemos usado "**outbound**-channel-adapter").

   *consumer-amqp.xml*

    ```xml
    <int-amqp:inbound-channel-adapter id="inputInternalSyncChannelAdapter"
    									  channel="ourChannelConsumer"
    									  queue-names="${integration.rabbitmq.internalSyncQueueName}"
    									  concurrent-consumers="${integration.rabbitmq.bulkInternalConcurrentConsumers}"
    									  mapped-request-headers="*"
    									  connection-factory="connectionFactoryConsume"
    									  auto-startup="false"/>

    <!-- queue-names="${integration..." es la cola por la que se enviaban los mensajes desde el publisher   -->
    <!-- ourChannelConsumer: channel al que estar√° suscrito nuestro consumer. -->
    ```

6. Por √∫ltimo, enrutaremos nuestro mensaje por el *channel* que queremos dependiendo del valor que traiga el entityType.

   *consumer-common.xml*

   ```xml
    <int:channel id="ourChannelConsumer"/>
    <!-- Enrutamos dependiendo del valor del entityType -->
    <int:header-value-router input-channel="ourChannelConsumer" header-name="entityType"
                                 default-output-channel="rejectionChannel" resolution-required="false">
        <int:mapping value="user" channel="userSyncChannel" />
    </int:header-value-router>

    <!-- Definimos el channel que necesitamos para consumir el mensaje -->
    <int:channel id="userSyncChannel"/>

    <!-- Definimos nuestro consumer -->
    <int:service-activator input-channel="userSyncChannel" ref="userSyncSubscriber" method="handleMessagePayload">
        <int:request-handler-advice-chain>
            <ref bean="retryAdvice"/>
        </int:request-handler-advice-chain>
    </int:service-activator>
    ```
   El mensaje que el *consumer* recibir√° ser√° algo como:

   ```bash
    Exchange	      	      	  myApp.sync.exchange
    Routing Key
    Redelivered
    Properties
    priority:	        	  0
    delivery_mode:	  	      2
    headers:
    entityType:	      	      user
    entityType:	      	  user
    eventType:	      	      sync
    content_encoding:	      UTF-8
    content_type:	    	  text/plain
    Payload           { "userId":"50c8d773459c40fda2dd23abbf353ba1" }
   ```

```
eventType:	      	      sync
content_encoding:	      UTF-8
content_type:	    	  text/plain
Payload           { "userId":"50c8d773459c40fda2dd23abbf353ba1" }
   ```

Ahora ya est√° todo configurado para que la clase "userSyncSubscriber.groovy" consuma nuestro evento y realice la l√≥gica de negocio en el m√©todo "handleMessagePayload".

Rabbitmq tiene infinidad de propiedades y configuraciones que se pueden usar. Esto s√≥lo ha sido una peque√±a introducci√≥n...üòÜ

Si has llegado hasta aqu√≠, mis felicitaciones „äóÔ∏è  y sobre todo, **GRACIAS**.

Cualquier pregunta o sugerencia ser√° bien recibida.

 Mar√≠a
