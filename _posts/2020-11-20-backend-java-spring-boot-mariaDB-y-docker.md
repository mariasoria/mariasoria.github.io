---
title: "Backend con Java Spring Boot - MariaDB y docker"

# multilingual page pair id, this must pair with translations of this page. (This name must be unique)
lng_pair: id_autogeneratedsamplecontent_3

# post specific
# if not specified, .name will be used from _data/owner/[language].yml
author: Maria Soria
# multiple category is not supported
category: auto generated
# multiple tag entries are possible
tags: [docker, backend]
# thumbnail image for post
img: ":docker.png"
# disable comments on this page
comments_disable: true

# publish date
date: 2020-11-20 17:25:34 +06:00

# seo
# if not specified, date will be used.
#meta_modify_date: 2021-08-10 11:32:53 +0900
# check the meta_common_description in _data/owner/[language].yml
#meta_description: ""

# optional
# if you enabled image_viewer_posts you don't need to enable this. This is only if image_viewer_posts = false
#image_viewer_on: true
# if you enabled image_lazy_loader_posts you don't need to enable this. This is only if image_lazy_loader_posts = false
#image_lazy_loader_on: true
# exclude from on site search
#on_site_search_exclude: true
# exclude from search engines
#search_engine_exclude: true
# to disable this page, simply set published: false or delete this file

---

Hoy voy a crear un contenedor de docker donde estará mi proyecto de backend de forma
que podré acceder a él desde donde quiera simplemente teniendo el contenedor
del docker levantado.

Mi backend está implementado en Java Spring Boot utilizando una base de datos MariaDB.

##### **Los pasos a seguir son los siguientes**:

**1-** Crear un Dockerfile a través del cual crearé una imagen que contendrá el proyecto backend
y al que accederé posteriormente a través de un contenedor. Para este ejemplo, lo haré a partir de una imagen ya
existente en docker hub: "*openjdk:8-jdk-alpine*". (Es probable que cuando leas esto haya
versiones más actualizadas. Usa la que más te convenga).

A continuación muestro los posibles comandos que se pueden incluir en este fichero:
- FROM: Crea la imagen desde la imagen que se indica.
- VOLUME: Indica en qué parte de tu equipo guardará la información que se genere.
- RUN: Va seguido de los comandos a ejecutar dentro del contenedor.
- CMD: Comando que se ejecutará al hacer *docker run* .
- LABEL: Etiquetar la imagen.
- EXPOSE: Exponer puertos.
- ARG: Tipo de argumentos que necesitará la imagen (en mi caso será un jar).
- ADD: Copia en el contenedor. Permite poner URLs.
- COPY: Copia lo que se indica dentro del contenedor, sólo rutas locales (ahí pondré la ruta al .jar y el nombre del archivo en cuestión).
- ENV: Variables de entorno a incluir en el contenedor.
- ENTRYPOINT: Lo que se indique aquí se ejecutará siempre que se arranque el contenedor.

Mi Dockerfile contendrá lo siguiente:
```dockerfile
FROM openjdk:8-jdk-alpine
VOLUME /tmp
EXPOSE 8080
ARG JAR_FILE
COPY target/cardatabase-0.0.1-SNAPSHOT.jar app.jar
ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/app.jar"]
```

**2-** Actualizar la información en el fichero *application.properties* para que el
acceso/llamadas a la BD las haga a la BD que habrá en el Docker y no a la local.

**cardb** es el nombre de mi BD y **pwd** es la contraseña que estableceré luego.

```
# Conexión mariadb en Docker
spring.datasource.url=jdbc:mariadb://mariadb:3306/cardb
spring.datasource.username=root
spring.datasource.password=pwd
spring.datasource.driver-class-name=org.mariadb.jdbc.Driver
spring.jpa.generate-ddl=true
spring.jpa.hibernate.ddl-auto=create-drop
spring.data.rest.basePath=/api
```

**3-** Crear el archivo .jar de la app que usaré en el contenedor de la aplicación y que he definido ya en el dockerfile en COPY:

`mvn clean install`

**4-** Crear la imagen de la aplicación estableciendo con *-t* el nombre de la imagen
que se desee (en mi caso será *carbackend* ). El *"."* indica que debe crear la
imagen a partir del directorio actual, ya que el Dockerfile se encuentra ahí.

`docker build -t carbackend .`

**5-** Revisar si se ha creado correctamente la imagen:

`docker image ls`

**6-** Añadir una base de datos (mariadb) a mi docker
(la BD será mariadb siendo la última versión disponible, esto es: *latest*):

Lo que hará, será descargar en mi equipo una imagen ya hecha que contiene la configuración de una BD mariadb.

`docker pull mariadb:latest`

**7-** Crear e iniciar un contenedor a partir de la imagen *mariadb* que se ha descargado.
(Además, crearé la contraseña que había añadido ya al application.properties).

Para hacer esto usaré el comando *run*:

**docker run [OPTIONS] imagen**

Siendo OPTIONS:

- ```- -name```: le doy un nombre al contenedor
- ```-e```: establece variables de entorno (establezco la contraseña y le digo que la BD se llama cardb)

El comando completo que usaré será:
`docker run --name cardb -e MYSQL_ROOT_PASSWORD=pwd -e MYSQL_DATABASE=cardb mariadb`

**8-** Crear e iniciar el contenedor con mi código backend (*carbackend* es el nombre de la app).
De nuevo, seguiré la estructura del comando *run*:

**docker run [OPTIONS] imagen**

Siendo OPTIONS esta vez las siguientes:

- ```-p p1:p2```: publica los puertos de un contenedor al host (p1: puerto en mi máquina, p2: puerto en Docker).
- ```- -name```: asigna un nombre al contenedor
- ```- -link```: enlaza este contenedor con el que yo le ponga
- ```-d```: ejecuta este comando en 2ºplano

El comando completo que usaré será:
`docker run -p 8080:8080 --name carapp --link cardb:mariadb -d carbackend`

**9-** Para esta aplicación, tengo también hecha la parte de frontend que apuntará a este
backend que acabo de configurar en docker. Así que levanto el frontend:

`npm start`

**10-** Abro el navegador y voy a: [http://localhost:3000/](http://localhost:3000/)  y compruebo que la aplicación se ejecuta normalmente.

Mi backend en docker está listo para ser usado por el frontend.
